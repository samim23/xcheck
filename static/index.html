<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>X-Check</title>
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		<link
			rel="stylesheet"
			href="/static/style.css"
			type="text/css"
			media="all"
		/>
	</head>
	<body>
		<div id="loadingSpinner" style="display: none">
			<div class="spinner"></div>
			<p>Loading...</p>
		</div>

		<h1>X-Check</h1>

		<div id="scrapeControls" class="card">
			<h2 class="card-title">X Account Management</h2>
			<div class="form-group">
				<label for="xUsername">X Username:</label>
				<input
					type="text"
					id="xUsername"
					class="form-input"
					placeholder="Enter X username"
				/>
			</div>
			<div class="form-group">
				<label for="xPassword">X Password:</label>
				<input
					type="password"
					id="xPassword"
					class="form-input"
					placeholder="Enter X password"
				/>
			</div>
			<button onclick="updateCredentials()" class="btn btn-primary">
				Update Credentials
			</button>

			<h2 class="card-title mt-4">Start New Scrape</h2>
			<div class="form-group">
				<label for="usernameInput">Target Username:</label>
				<input
					type="text"
					id="usernameInput"
					class="form-input"
					placeholder="Enter target X username"
				/>
			</div>
			<div class="form-group">
				<label for="maxFollowersInput">Max Followers:</label>
				<input
					type="number"
					id="maxFollowersInput"
					class="form-input"
					placeholder="Enter max followers to scrape"
				/>
			</div>
			<button onclick="startScrape()" class="btn btn-success">
				Start Scrape
			</button>

			<div id="scrapeProgress" class="mt-4" style="display: none">
				<p>Status: <span id="scrapeStatus" class="font-bold"></span></p>
				<progress
					id="scrapeProgressBar"
					value="0"
					max="100"
					class="w-full"
				></progress>
				<button onclick="toggleStatusMessages()" class="btn btn-primary mt-2">
					Toggle Status Messages
				</button>
				<div
					id="statusMessages"
					style="
						display: none;
						max-height: 200px;
						overflow-y: auto;
						background-color: #f0f0f0;
						padding: 10px;
						margin-top: 10px;
					"
				></div>
			</div>
		</div>

		<div class="charts-container">
			<div class="chart-container">
				<h2>Follower Quality Distribution</h2>
				<canvas id="qualityChart"></canvas>
			</div>
			<div class="chart-container">
				<h2>Verified Account Distribution</h2>
				<canvas id="verifiedChart"></canvas>
			</div>
		</div>

		<div id="searchBox">
			<input type="text" id="searchInput" placeholder="Search followers..." />
			<button onclick="searchFollowers()">Search</button>
		</div>

		<div id="filterOptions">
			<label for="followerCountFilter">Minimum Follower Count:</label>
			<input type="number" id="followerCountFilter" min="0" />

			<label for="accountAgeFilter">Minimum Account Age (days):</label>
			<input type="number" id="accountAgeFilter" min="0" />

			<label for="verificationFilter">Verification Status:</label>
			<select id="verificationFilter">
				<option value="all">All</option>
				<option value="verified">Verified</option>
				<option value="unverified">Unverified</option>
			</select>

			<button onclick="applyFilters()">Apply Filters</button>
		</div>

		<h2>Follower Data</h2>
		<table id="followerTable">
			<thead>
				<tr>
					<th>Handle</th>
					<th>Name</th>
					<th class="sortable" data-sort="quality_score">Quality Score</th>
					<th class="sortable" data-sort="is_bot">Is Bot</th>
					<th class="sortable" data-sort="follower_count">Follower Count</th>
					<th class="sortable" data-sort="following_count">Following Count</th>
					<th class="sortable" data-sort="account_age_days">
						Account Age (days)
					</th>
					<th>Verified</th>
				</tr>
			</thead>
			<tbody id="followerTableBody"></tbody>
		</table>

		<div id="debug">
			<h3>Debug Information</h3>
			<pre id="debugInfo"></pre>
		</div>

		<script>
			function toggleStatusMessages() {
				const statusMessages = document.getElementById("statusMessages");
				statusMessages.style.display =
					statusMessages.style.display === "none" ? "block" : "none";
			}

			function calculateMedian(numbers) {
				if (numbers.length === 0) return 0;
				const sorted = numbers.slice().sort((a, b) => a - b);
				const middle = Math.floor(sorted.length / 2);
				if (sorted.length % 2 === 0) {
					return (sorted[middle - 1] + sorted[middle]) / 2;
				}
				return sorted[middle];
			}

			function searchFollowers() {
				const searchTerm = document
					.getElementById("searchInput")
					.value.toLowerCase();
				const searchResults = followers.filter(
					(follower) =>
						follower.name.toLowerCase().includes(searchTerm) ||
						follower.handle.toLowerCase().includes(searchTerm)
				);
				renderTable(searchResults);
				updateCharts(searchResults);
			}

			let followers = [];
			let currentSort = { column: "follower_order", direction: "asc" };

			function sortFollowers(column) {
				if (column === currentSort.column) {
					currentSort.direction =
						currentSort.direction === "asc" ? "desc" : "asc";
				} else {
					currentSort.column = column;
					currentSort.direction = "asc";
				}

				if (column === "follower_order") {
					// For follower_order, we'll fetch from the server with the new sorting
					fetchFollowerData(column, currentSort.direction);
				} else {
					// For other columns, we'll sort client-side
					followers.sort((a, b) => {
						let valueA = a[column];
						let valueB = b[column];

						// Special handling for account age
						if (column === "account_age_days") {
							valueA =
								a.days_since_joining !== undefined
									? parseInt(a.days_since_joining)
									: -1;
							valueB =
								b.days_since_joining !== undefined
									? parseInt(b.days_since_joining)
									: -1;
						} else {
							// Convert to numbers if possible for other columns
							if (!isNaN(valueA)) valueA = parseFloat(valueA);
							if (!isNaN(valueB)) valueB = parseFloat(valueB);

							// Handle string comparisons
							if (typeof valueA === "string") valueA = valueA.toLowerCase();
							if (typeof valueB === "string") valueB = valueB.toLowerCase();
						}

						if (valueA < valueB)
							return currentSort.direction === "asc" ? -1 : 1;
						if (valueA > valueB)
							return currentSort.direction === "asc" ? 1 : -1;
						return 0;
					});

					renderTable();
				}

				updateSortIndicators();
			}

			function updateSortIndicators() {
				document.querySelectorAll("th.sortable").forEach((th) => {
					th.classList.remove("asc", "desc");
					if (th.dataset.sort === currentSort.column) {
						th.classList.add(currentSort.direction);
					}
				});
			}

			function applyFilters() {
				const minFollowers =
					parseInt(document.getElementById("followerCountFilter").value) || 0;
				const minAge =
					parseInt(document.getElementById("accountAgeFilter").value) || 0;
				const verificationStatus =
					document.getElementById("verificationFilter").value;

				const filteredFollowers = followers.filter((follower) => {
					const followerCount = parseInt(follower.follower_count) || 0;
					const accountAge = parseInt(follower.days_since_joining) || 0;
					const isVerified = follower.verified === true;

					return (
						followerCount >= minFollowers &&
						accountAge >= minAge &&
						(verificationStatus === "all" ||
							(verificationStatus === "verified" && isVerified) ||
							(verificationStatus === "unverified" && !isVerified))
					);
				});

				renderTable(filteredFollowers);
				updateCharts(filteredFollowers);
			}

			function renderTable(data = followers) {
				const tableBody = document.getElementById("followerTableBody");
				tableBody.innerHTML = "";
				data.forEach((follower) => {
					const row = tableBody.insertRow();

					// Add follower order cell
					row.insertCell(0).textContent = follower.follower_order;

					// Add profile image cell
					const imageCell = row.insertCell(1);
					const img = document.createElement("img");
					img.src = follower.profile_image_url || "/path/to/default/image.png";
					img.alt = "Profile picture";
					img.style.width = "32px";
					img.style.height = "32px";
					img.style.borderRadius = "50%";
					imageCell.appendChild(img);

					const handleCell = row.insertCell(2);
					const handleLink = document.createElement("a");
					handleLink.href = `https://twitter.com/${follower.handle.replace(
						"@",
						""
					)}`;
					handleLink.textContent = follower.handle || "N/A";
					handleLink.className = "profile-link";
					handleLink.target = "_blank";
					handleLink.rel = "noopener noreferrer";
					handleCell.appendChild(handleLink);

					row.insertCell(3).textContent = follower.name || "N/A";
					row.insertCell(4).textContent =
						typeof follower.quality_score === "number"
							? follower.quality_score.toFixed(2)
							: "N/A";
					row.insertCell(5).textContent = follower.is_bot;
					row.insertCell(6).textContent = follower.follower_count || "N/A";
					row.insertCell(7).textContent = follower.following_count || "N/A";
					row.insertCell(8).textContent =
						follower.days_since_joining !== undefined
							? parseInt(follower.days_since_joining)
							: "N/A";
					row.insertCell(9).textContent = follower.verified ? "Yes" : "No";
				});
			}

			async function fetchFollowerData(
				sortBy = "follower_order",
				sortDirection = "asc"
			) {
				document.getElementById("loadingSpinner").style.display = "flex";
				const response = await fetch(
					`/api/followers?sort_by=${sortBy}&sort_direction=${sortDirection}`
				);
				const data = await response.json();
				followers = data;
				console.log("First follower object:", followers[0]);
				document.getElementById("debugInfo").textContent = JSON.stringify(
					followers[0],
					null,
					2
				);

				const qualityScores = followers
					.map((f) => f.quality_score)
					.filter((score) => score !== undefined && score !== null);
				console.log("Quality scores:", qualityScores);

				const medianScore = calculateMedian(qualityScores);
				const highQuality = qualityScores.filter(
					(score) => score > medianScore
				).length;
				const lowQuality = qualityScores.length - highQuality;

				const verifiedCount = followers.filter((f) => f.verified).length;
				const unverifiedCount = followers.length - verifiedCount;

				followers = data;
				renderTable();
				updateCharts();
				document.getElementById("loadingSpinner").style.display = "none";
			}

			function updateCharts(data = followers) {
				// Ensure data is an array
				if (!Array.isArray(data)) {
					console.error("updateCharts received invalid data:", data);
					data = []; // Use an empty array to avoid further errors
				}

				// Calculate highQuality, lowQuality, verifiedCount, and unverifiedCount from the data
				const qualityScores = data
					.map((f) => f.quality_score)
					.filter(
						(score) => score !== undefined && score !== null && !isNaN(score)
					);

				const medianScore = calculateMedian(qualityScores);
				const highQuality = qualityScores.filter(
					(score) => score > medianScore
				).length;
				const lowQuality = qualityScores.length - highQuality;

				const verifiedCount = data.filter((f) => f.verified === true).length;
				const unverifiedCount = data.length - verifiedCount;

				// Destroy existing charts if they exist
				if (
					window.qualityChart &&
					typeof window.qualityChart.destroy === "function"
				) {
					window.qualityChart.destroy();
				}
				if (
					window.verifiedChart &&
					typeof window.verifiedChart.destroy === "function"
				) {
					window.verifiedChart.destroy();
				}

				// Create new charts
				const qualityChartCtx = document
					.getElementById("qualityChart")
					.getContext("2d");
				window.qualityChart = new Chart(qualityChartCtx, {
					type: "pie",
					data: {
						labels: ["High Quality", "Low Quality"],
						datasets: [
							{
								data: [highQuality, lowQuality],
								backgroundColor: ["#1DA1F2", "#AAB8C2"],
							},
						],
					},
				});

				const verifiedChartCtx = document
					.getElementById("verifiedChart")
					.getContext("2d");
				window.verifiedChart = new Chart(verifiedChartCtx, {
					type: "pie",
					data: {
						labels: ["Verified", "Not Verified"],
						datasets: [
							{
								data: [verifiedCount, unverifiedCount],
								backgroundColor: ["#1DA1F2", "#AAB8C2"],
							},
						],
					},
				});
			}

			async function startScrape() {
				const username = document.getElementById("usernameInput").value;
				const maxFollowers = document.getElementById("maxFollowersInput").value;

				if (!username || !maxFollowers) {
					alert("Please enter both username and max followers");
					return;
				}

				const response = await fetch("/api/scrape", {
					method: "POST",
					headers: {
						"Content-Type": "application/json",
					},
					body: JSON.stringify({
						username,
						max_followers: parseInt(maxFollowers),
					}),
				});

				if (response.ok) {
					document.getElementById("scrapeProgress").style.display = "block";
					document.getElementById("scrapeStatus").textContent = "Starting...";
					document.getElementById("scrapeProgressBar").value = 0;
					checkScrapeStatus();
				} else {
					alert("Failed to start scrape");
				}
			}

			async function checkScrapeStatus() {
				const response = await fetch("/api/scrape-status");
				const status = await response.json();

				document.getElementById("scrapeStatus").textContent = status.status;
				const statusMessages = document.getElementById("statusMessages");

				if (status.status === "running") {
					const progress = (status.progress / status.total) * 100;
					document.getElementById("scrapeProgressBar").value = progress;

					// Update status messages
					statusMessages.innerHTML = status.messages
						.map((msg) => `<p>${msg}</p>`)
						.join("");
					statusMessages.scrollTop = statusMessages.scrollHeight;

					setTimeout(checkScrapeStatus, 1000);
				} else if (status.status === "completed") {
					document.getElementById("scrapeProgressBar").value = 100;
					statusMessages.innerHTML += "<p>Scrape completed!</p>";
					alert("Scrape completed!");
					fetchFollowerData();
				} else if (status.status === "error") {
					document.getElementById("scrapeProgressBar").value = 100;
					document.getElementById("scrapeStatus").textContent =
						"Error: " + status.messages[status.messages.length - 1];
					statusMessages.innerHTML += `<p>Error: ${
						status.messages[status.messages.length - 1]
					}</p>`;
					alert(
						`Scrape failed: ${status.messages[status.messages.length - 1]}`
					);
				}
			}

			async function fetchCredentials() {
				const response = await fetch("/api/credentials");
				const data = await response.json();
				document.getElementById("xUsername").value = data.username;
				document.getElementById("xPassword").value = data.password;
			}

			async function updateCredentials() {
				const username = document.getElementById("xUsername").value;
				const password = document.getElementById("xPassword").value;

				const response = await fetch("/api/credentials", {
					method: "POST",
					headers: {
						"Content-Type": "application/json",
					},
					body: JSON.stringify({ username, password }),
				});

				const result = await response.json();
				alert(result.message);
			}

			// event listeners
			document.addEventListener("DOMContentLoaded", () => {
				fetchCredentials();
				const headerRow = document.querySelector("#followerTable thead tr");

				// Add follower order header
				const orderHeader = document.createElement("th");
				orderHeader.textContent = "Follow Order";
				orderHeader.classList.add("sortable");
				orderHeader.dataset.sort = "follower_order";
				headerRow.insertBefore(orderHeader, headerRow.firstChild);

				// Add profile image header
				const imageHeader = document.createElement("th");
				imageHeader.textContent = "Profile";
				headerRow.insertBefore(imageHeader, headerRow.children[1]);

				// Add event listener for search input
				document
					.getElementById("searchInput")
					.addEventListener("input", searchFollowers);

				// Initialize charts with dummy data
				updateCharts(0, 0, 0, 0);

				fetchFollowerData();
				document.querySelectorAll("th.sortable").forEach((th) => {
					th.addEventListener("click", () => sortFollowers(th.dataset.sort));
				});
			});
		</script>
	</body>
</html>
