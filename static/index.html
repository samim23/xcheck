<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>X-Check</title>
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		<link
			rel="stylesheet"
			href="/static/style.css"
			type="text/css"
			media="all"
		/>
	</head>
	<body>
		<div id="loadingSpinner" style="display: none">
			<div class="spinner"></div>
			<p>Loading...</p>
		</div>

		<div class="main-container">
			<button id="sidebarToggle" class="sidebar-toggle">â˜°</button>

			<aside id="sidebar" class="sidebar">
				<div class="card">
					<div class="header">XCHECK</div>
					<div class="card-section">
						<h2 class="card-title">X Account Details</h2>
						<div class="form-group">
							<label for="xUsername">Username</label>
							<input
								type="text"
								id="xUsername"
								class="form-input"
								placeholder="Enter X username"
							/>
						</div>
						<div class="form-group">
							<label for="xPassword">Password</label>
							<input
								type="password"
								id="xPassword"
								class="form-input"
								placeholder="Enter X password"
							/>
						</div>
						<button onclick="updateCredentials()" class="btn btn-primary">
							Update Credentials
						</button>
					</div>

					<div class="card-section">
						<h2 class="card-title">Start New Scrape</h2>
						<div class="form-group">
							<label for="usernameInput">Target Username</label>
							<input
								type="text"
								id="usernameInput"
								class="form-input"
								placeholder="Enter target X username"
							/>
						</div>
						<div class="form-group">
							<label for="maxFollowersInput">Max Followers</label>
							<input
								type="number"
								id="maxFollowersInput"
								class="form-input"
								placeholder="Enter max followers to scrape"
							/>
						</div>
						<button onclick="startScrape()" class="btn btn-success">
							Start Scrape
						</button>
					</div>

					<div id="scrapeProgress" class="card-section" style="display: none">
						<h2 class="card-title">Scrape Progress</h2>
						<p>Status: <span id="scrapeStatus" class="font-bold"></span></p>
						<progress
							id="scrapeProgressBar"
							value="0"
							max="100"
							class="w-full"
						></progress>
						<button
							onclick="toggleStatusMessages()"
							class="btn btn-secondary mt-2"
						>
							Toggle Status Messages
						</button>
						<div id="statusMessages" class="status-messages"></div>
					</div>
				</div>
			</aside>

			<main class="main-content">
				<h2>Followers</h2>

				<div class="search-filter-container">
					<div class="search-box">
						<input
							type="text"
							id="searchInput"
							placeholder="Search followers..."
						/>
						<button onclick="searchFollowers()" class="icon-button">
							<i class="fas fa-search"></i>
						</button>
					</div>

					<div class="filter-toggle">
						<button onclick="toggleFilters()" class="btn btn-secondary">
							<i class="fas fa-filter"></i> Filters
						</button>
					</div>

					<div id="filterOptions" class="filter-panel">
						<div class="filter-group">
							<label for="followerCountFilter">Minimum Followers</label>
							<input
								type="number"
								id="followerCountFilter"
								min="0"
								placeholder="e.g., 1000"
							/>
						</div>

						<div class="filter-group">
							<label for="accountAgeFilter">Minimum Account Age (days)</label>
							<input
								type="number"
								id="accountAgeFilter"
								min="0"
								placeholder="e.g., 30"
							/>
						</div>

						<div class="filter-group">
							<label for="verificationFilter">Verification Status</label>
							<select id="verificationFilter">
								<option value="all">All</option>
								<option value="verified">Verified</option>
								<option value="unverified">Unverified</option>
							</select>
						</div>

						<div class="filter-actions">
							<button onclick="applyFilters()" class="btn btn-primary">
								Apply Filters
							</button>
							<button onclick="resetFilters()" class="btn btn-secondary">
								Reset
							</button>
						</div>
					</div>
				</div>

				<div class="charts-section">
					<h2 class="charts-toggle" onclick="toggleCharts()">
						Charts
						<svg class="caret-icon" width="10" height="10" viewBox="0 0 10 10">
							<path
								d="M1 3L5 7L9 3"
								fill="none"
								stroke="currentColor"
								stroke-width="2"
								stroke-linecap="round"
							/>
						</svg>
					</h2>
					<div
						id="chartsContainer"
						class="charts-container"
						style="display: none"
					>
						<div class="chart-container">
							<h3>Follower Quality Distribution</h3>
							<canvas id="qualityChart"></canvas>
						</div>
						<div class="chart-container">
							<h3>Verified Account Distribution</h3>
							<canvas id="verifiedChart"></canvas>
						</div>
					</div>
				</div>

				<table id="followerTable">
					<thead>
						<tr>
							<th>Handle</th>
							<th>Name</th>
							<th class="sortable" data-sort="quality_score">Quality Score</th>
							<th class="sortable" data-sort="follower_count">
								Follower Count
							</th>
							<th class="sortable" data-sort="following_count">
								Following Count
							</th>
							<th class="sortable" data-sort="account_age_days">
								Account Age (days)
							</th>
							<th>Verified</th>
						</tr>
					</thead>
					<tbody id="followerTableBody"></tbody>
				</table>

				<div id="debug">
					<h3>Debug Information</h3>
					<pre id="debugInfo"></pre>
				</div>
			</main>
		</div>

		<script>
			function toggleCharts() {
				const chartsContainer = document.getElementById("chartsContainer");
				const chartsToggle = document.querySelector(".charts-toggle");

				if (chartsContainer.style.display === "none") {
					chartsContainer.style.display = "flex";
					chartsToggle.classList.add("open");

					// Only update charts if they haven't been rendered yet
					if (!window.chartsRendered) {
						updateCharts();
						window.chartsRendered = true;
					}
				} else {
					chartsContainer.style.display = "none";
					chartsToggle.classList.remove("open");
				}
			}

			function toggleStatusMessages() {
				const statusMessages = document.getElementById("statusMessages");
				statusMessages.style.display =
					statusMessages.style.display === "none" ? "block" : "none";
			}

			function calculateMedian(numbers) {
				if (numbers.length === 0) return 0;
				const sorted = numbers.slice().sort((a, b) => a - b);
				const middle = Math.floor(sorted.length / 2);
				if (sorted.length % 2 === 0) {
					return (sorted[middle - 1] + sorted[middle]) / 2;
				}
				return sorted[middle];
			}

			function searchFollowers() {
				const searchTerm = document
					.getElementById("searchInput")
					.value.toLowerCase();
				const searchResults = followers.filter(
					(follower) =>
						follower.name.toLowerCase().includes(searchTerm) ||
						follower.handle.toLowerCase().includes(searchTerm)
				);
				renderTable(searchResults);
				updateCharts(searchResults);
			}

			let followers = [];
			let currentSort = { column: "follower_order", direction: "asc" };

			function sortFollowers(column) {
				if (column === currentSort.column) {
					currentSort.direction =
						currentSort.direction === "asc" ? "desc" : "asc";
				} else {
					currentSort.column = column;
					currentSort.direction = "asc";
				}

				if (column === "follower_order") {
					// For follower_order, we'll fetch from the server with the new sorting
					fetchFollowerData(column, currentSort.direction);
				} else {
					// For other columns, we'll sort client-side
					followers.sort((a, b) => {
						let valueA = a[column];
						let valueB = b[column];

						// Special handling for account age
						if (column === "account_age_days") {
							valueA =
								a.days_since_joining !== undefined
									? parseInt(a.days_since_joining)
									: -1;
							valueB =
								b.days_since_joining !== undefined
									? parseInt(b.days_since_joining)
									: -1;
						} else {
							// Convert to numbers if possible for other columns
							if (!isNaN(valueA)) valueA = parseFloat(valueA);
							if (!isNaN(valueB)) valueB = parseFloat(valueB);

							// Handle string comparisons
							if (typeof valueA === "string") valueA = valueA.toLowerCase();
							if (typeof valueB === "string") valueB = valueB.toLowerCase();
						}

						if (valueA < valueB)
							return currentSort.direction === "asc" ? -1 : 1;
						if (valueA > valueB)
							return currentSort.direction === "asc" ? 1 : -1;
						return 0;
					});

					renderTable();
				}

				updateSortIndicators();
			}

			function updateSortIndicators() {
				document.querySelectorAll("th.sortable").forEach((th) => {
					th.classList.remove("asc", "desc");
					if (th.dataset.sort === currentSort.column) {
						th.classList.add(currentSort.direction);
					}
				});
			}

			function applyFilters() {
				const minFollowers =
					parseInt(document.getElementById("followerCountFilter").value) || 0;
				const minAge =
					parseInt(document.getElementById("accountAgeFilter").value) || 0;
				const verificationStatus =
					document.getElementById("verificationFilter").value;

				const filteredFollowers = followers.filter((follower) => {
					const followerCount = parseInt(follower.follower_count) || 0;
					const accountAge = parseInt(follower.days_since_joining) || 0;
					const isVerified = follower.verified === true;

					return (
						followerCount >= minFollowers &&
						accountAge >= minAge &&
						(verificationStatus === "all" ||
							(verificationStatus === "verified" && isVerified) ||
							(verificationStatus === "unverified" && !isVerified))
					);
				});

				renderTable(filteredFollowers);
				updateCharts(filteredFollowers);
			}

			function renderTable(data = followers) {
				const tableBody = document.getElementById("followerTableBody");
				tableBody.innerHTML = "";
				data.forEach((follower) => {
					const row = tableBody.insertRow();

					// Add follower order cell
					row.insertCell(0).textContent = follower.follower_order;

					// Add profile image cell
					const imageCell = row.insertCell(1);
					const img = document.createElement("img");
					img.src = follower.profile_image_url || "/path/to/default/image.png";
					img.alt = "Profile picture";
					img.style.width = "32px";
					img.style.height = "32px";
					img.style.borderRadius = "50%";
					imageCell.appendChild(img);

					const handleCell = row.insertCell(2);
					const handleLink = document.createElement("a");
					handleLink.href = `https://twitter.com/${follower.handle.replace(
						"@",
						""
					)}`;
					handleLink.textContent = follower.handle || "N/A";
					handleLink.className = "profile-link";
					handleLink.target = "_blank";
					handleLink.rel = "noopener noreferrer";
					handleCell.appendChild(handleLink);

					row.insertCell(3).textContent = follower.name || "N/A";
					row.insertCell(4).textContent =
						typeof follower.quality_score === "number"
							? follower.quality_score.toFixed(2)
							: "N/A";
					row.insertCell(5).textContent = follower.follower_count || "N/A";
					row.insertCell(6).textContent = follower.following_count || "N/A";
					row.insertCell(7).textContent =
						follower.days_since_joining !== undefined
							? parseInt(follower.days_since_joining)
							: "N/A";
					row.insertCell(8).textContent = follower.verified ? "Yes" : "No";
				});
			}

			async function fetchFollowerData(
				sortBy = "follower_order",
				sortDirection = "asc"
			) {
				document.getElementById("loadingSpinner").style.display = "flex";
				const response = await fetch(
					`/api/followers?sort_by=${sortBy}&sort_direction=${sortDirection}`
				);
				const data = await response.json();
				followers = data;
				console.log("First follower object:", followers[0]);
				document.getElementById("debugInfo").textContent = JSON.stringify(
					followers[0],
					null,
					2
				);

				const qualityScores = followers
					.map((f) => f.quality_score)
					.filter((score) => score !== undefined && score !== null);
				console.log("Quality scores:", qualityScores);

				const medianScore = calculateMedian(qualityScores);
				const highQuality = qualityScores.filter(
					(score) => score > medianScore
				).length;
				const lowQuality = qualityScores.length - highQuality;

				const verifiedCount = followers.filter((f) => f.verified).length;
				const unverifiedCount = followers.length - verifiedCount;

				followers = data;
				renderTable();
				updateCharts();
				document.getElementById("loadingSpinner").style.display = "none";
			}

			function updateCharts(data = followers) {
				// Ensure data is an array
				if (!Array.isArray(data)) {
					console.error("updateCharts received invalid data:", data);
					data = []; // Use an empty array to avoid further errors
				}

				// Calculate highQuality, lowQuality, verifiedCount, and unverifiedCount from the data
				const qualityScores = data
					.map((f) => f.quality_score)
					.filter(
						(score) => score !== undefined && score !== null && !isNaN(score)
					);

				const medianScore = calculateMedian(qualityScores);
				const highQuality = qualityScores.filter(
					(score) => score > medianScore
				).length;
				const lowQuality = qualityScores.length - highQuality;

				const verifiedCount = data.filter((f) => f.verified === true).length;
				const unverifiedCount = data.length - verifiedCount;

				// Destroy existing charts if they exist
				if (
					window.qualityChart &&
					typeof window.qualityChart.destroy === "function"
				) {
					window.qualityChart.destroy();
				}
				if (
					window.verifiedChart &&
					typeof window.verifiedChart.destroy === "function"
				) {
					window.verifiedChart.destroy();
				}

				// Create new charts
				const qualityChartCtx = document
					.getElementById("qualityChart")
					.getContext("2d");
				window.qualityChart = new Chart(qualityChartCtx, {
					type: "pie",
					data: {
						labels: ["High Quality", "Low Quality"],
						datasets: [
							{
								data: [highQuality, lowQuality],
								backgroundColor: ["#1DA1F2", "#AAB8C2"],
							},
						],
					},
				});

				const verifiedChartCtx = document
					.getElementById("verifiedChart")
					.getContext("2d");
				window.verifiedChart = new Chart(verifiedChartCtx, {
					type: "pie",
					data: {
						labels: ["Verified", "Not Verified"],
						datasets: [
							{
								data: [verifiedCount, unverifiedCount],
								backgroundColor: ["#1DA1F2", "#AAB8C2"],
							},
						],
					},
				});
				// Set the flag to indicate charts have been rendered
				window.chartsRendered = true;
			}

			async function startScrape() {
				const scrapeButton = document.querySelector("button.btn.btn-success");
				scrapeButton.disabled = true;
				scrapeButton.textContent = "Scraping...";

				const username = document.getElementById("usernameInput").value;
				const maxFollowers = document.getElementById("maxFollowersInput").value;

				if (!username || !maxFollowers) {
					alert("Please enter both username and max followers");
					return;
				}

				const response = await fetch("/api/scrape", {
					method: "POST",
					headers: {
						"Content-Type": "application/json",
					},
					body: JSON.stringify({
						username,
						max_followers: parseInt(maxFollowers),
					}),
				});

				if (response.ok) {
					document.getElementById("scrapeProgress").style.display = "block";
					document.getElementById("scrapeStatus").textContent = "Starting...";
					document.getElementById("scrapeProgressBar").value = 0;
					checkScrapeStatus();
				} else {
					alert("Failed to start scrape");
					scrapeButton.disabled = false;
					scrapeButton.textContent = "Start Scrape";
				}
			}

			async function checkScrapeStatus() {
				const response = await fetch("/api/scrape-status");
				const status = await response.json();

				document.getElementById("scrapeStatus").textContent = status.status;
				const statusMessages = document.getElementById("statusMessages");

				if (status.status === "running") {
					const progress = (status.progress / status.total) * 100;
					document.getElementById("scrapeProgressBar").value = progress;

					// Update status messages
					statusMessages.innerHTML = status.messages
						.map((msg) => `<p>${msg}</p>`)
						.join("");
					statusMessages.scrollTop = statusMessages.scrollHeight;

					// Fetch and display partial results
					const partialResultsResponse = await fetch("/api/partial-results");
					const partialResultsData = await partialResultsResponse.json();
					renderTable(partialResultsData.partial_results);
					updateCharts(partialResultsData.partial_results);

					setTimeout(checkScrapeStatus, 5000); // Check every 5 seconds
				} else if (status.status === "completed") {
					document.getElementById("scrapeProgressBar").value = 100;
					statusMessages.innerHTML += "<p>Scrape completed!</p>";
					alert("Scrape completed!");
					fetchFollowerData(); // Fetch all data once completed
				} else if (status.status === "error") {
					document.getElementById("scrapeProgressBar").value = 100;
					document.getElementById("scrapeStatus").textContent =
						"Error: " + status.messages[status.messages.length - 1];
					statusMessages.innerHTML += `<p>Error: ${
						status.messages[status.messages.length - 1]
					}</p>`;
					alert(
						`Scrape failed: ${status.messages[status.messages.length - 1]}`
					);
				}
			}

			async function fetchCredentials() {
				const response = await fetch("/api/credentials");
				const data = await response.json();
				document.getElementById("xUsername").value = data.username;
				document.getElementById("xPassword").value = data.password;
			}

			async function updateCredentials() {
				const username = document.getElementById("xUsername").value;
				const password = document.getElementById("xPassword").value;

				const response = await fetch("/api/credentials", {
					method: "POST",
					headers: {
						"Content-Type": "application/json",
					},
					body: JSON.stringify({ username, password }),
				});

				const result = await response.json();
				alert(result.message);
			}

			// event listeners
			document.addEventListener("DOMContentLoaded", () => {
				fetchCredentials();
				const headerRow = document.querySelector("#followerTable thead tr");

				// Add follower order header
				const orderHeader = document.createElement("th");
				orderHeader.textContent = "Follow Order";
				orderHeader.classList.add("sortable");
				orderHeader.dataset.sort = "follower_order";
				headerRow.insertBefore(orderHeader, headerRow.firstChild);

				// Add profile image header
				const imageHeader = document.createElement("th");
				imageHeader.textContent = "Profile";
				headerRow.insertBefore(imageHeader, headerRow.children[1]);

				// Add event listener for search input
				document
					.getElementById("searchInput")
					.addEventListener("input", searchFollowers);

				// Initialize charts with dummy data
				updateCharts(0, 0, 0, 0);

				fetchFollowerData();
				document.querySelectorAll("th.sortable").forEach((th) => {
					th.addEventListener("click", () => sortFollowers(th.dataset.sort));
				});

				// Initialize chartsRendered flag
				window.chartsRendered = false;

				// Sidebar control
				const sidebar = document.getElementById("sidebar");
				const sidebarToggle = document.getElementById("sidebarToggle");
				const mainContent = document.querySelector(".main-content");

				function toggleSidebar() {
					sidebar.classList.toggle("open");
					if (sidebar.classList.contains("open")) {
						mainContent.style.marginLeft = "300px";
					} else {
						mainContent.style.marginLeft = "0";
					}
				}

				sidebarToggle.addEventListener("click", toggleSidebar);

				// Close sidebar when clicking outside of it on mobile
				document.addEventListener("click", function (event) {
					const isClickInsideSidebar = sidebar.contains(event.target);
					const isClickOnToggleButton = sidebarToggle.contains(event.target);
					if (
						!isClickInsideSidebar &&
						!isClickOnToggleButton &&
						window.innerWidth <= 768
					) {
						sidebar.classList.remove("open");
						mainContent.style.marginLeft = "0";
					}
				});

				// Adjust layout on window resize
				window.addEventListener("resize", function () {
					if (window.innerWidth > 768) {
						sidebar.classList.remove("open");
						mainContent.style.marginLeft = "300px";
					} else {
						mainContent.style.marginLeft = "0";
					}
				});
			});

			function toggleFilters() {
				const filterPanel = document.getElementById("filterOptions");
				if (
					filterPanel.style.display === "none" ||
					filterPanel.style.display === ""
				) {
					filterPanel.style.display = "block";
				} else {
					filterPanel.style.display = "none";
				}
			}

			function resetFilters() {
				document.getElementById("followerCountFilter").value = "";
				document.getElementById("accountAgeFilter").value = "";
				document.getElementById("verificationFilter").value = "all";
				applyFilters();
			}
		</script>
	</body>
</html>
